
% Define the filter size we will use in step 2:
filtsize = 85;

% Creating test image 'im' by splicing together two built in images.
% Also zero-padding (adding zeros around the border) with half the 
% filter size (filtsize) we will use so that the filter could be 
% centered on any actual image pixel, including those near the border.
% 'coins.png' contains bright nickels and dimes on a dark background
% 'eight.tif' contains dark quarters on a bright background, so we invert it
% to match 'coins.png'
im1 = imread('coins.png');
[r,c] = size(im1);
im2 = imread('eight.tif');
[r2,c2] = size(im2);
filtsizeh = floor(filtsize/2);
im = zeros(r+r2+filtsize,c+filtsize);
im(filtsizeh+1:filtsizeh+r+r2,filtsizeh+1:filtsizeh+c) = [im1;255-im2(:,1:c)];
[r,c] = size(im);
imagesc(im);colormap(gray);title('test image');axis equal;

% Initializing assessed/displayed variables as empty so that code is executable 
msk=[]; msk_dil=[]; msk_dil_erd=[]; centroid=[]; component_size=[]; 

%%%%% 1. Localize the centroid of each coin
% Otsu threshold
insithr = (imhist(im))
threshold = otsuthresh(insithr)*255
msk = im>threshold

figure; imagesc(msk); colormap(gray); title('Otsu'); axis equal;

% Dilate 
msk_dilate = imdilate(msk,ones(3,2))

figure; imagesc(msk_dil); colormap(gray); title('Dilated'); axis equal;

% Erode 
msk_erode = imerode(msk_dilate,ones(6,6));
figure; imagesc(msk_dil_erd); colormap(gray); title('Eroded'); axis equal;

% Connected components to get centroids of coins:

size_comp = bwconncomp(msk_erode);
props_coins = regionprops(msk_erode,'centroid');
centroid = vertcat(props_coins.Centroid)
for i=1:14
    for j=1:2
        if ceil(centroid(i,j))-centroid(i,j)>=0.5
            centroid(i,j)=ceil(centroid(i,j));
        else 
            centroid(i,j)=floor(centroid(i,j));
        end
    end
end 
centroid
component_size

%%%%% 2. Measure features for each coin using a bank of matching filters
% make matching filters to create features
% Define diameters to use for filters
dimediameter = 31;
quarterdiameter = 51;
nickeldiameter = 41;

% Initialize assessed variables
D=[]; nickelfilter = []; dimefilter = []; quarterfilter = [];

% Use the MakeCircleMatchingFilter function to create matching filters for dimes, nickels, and quarters
% (This is in a separate Matlab grader problem. Save your work, 
%       complete the corresponding grader problem and embed the solution 
%       in the helper function list below.)

dimefilter= MakeCircleMatchingFilter(dimediameter,filtsize);
nickelfilter= MakeCircleMatchingFilter(nickeldiameter,filtsize);
quarterfilter= MakeCircleMatchingFilter(quarterdiameter,filtsize);

figure;
subplot(1,3,1); imagesc(dimefilter); colormap(gray); title('dime filter'); axis tight equal;
subplot(1,3,2); imagesc(nickelfilter); colormap(gray); title('nickel filter'); axis tight equal;
subplot(1,3,3); imagesc(quarterfilter); colormap(gray); title('quarter filter'); axis tight equal;

% Evaluate each of the 3 matching filters on each coin to serve as 3 feature measurements 
D=zeros( length(centroid) ,3); 
for a = 1:length(centroid)
    sliced=msk_dil_erd(centroid(a,2)-filtsizeh:centroid(a,2)+filtsizeh,centroid(a,1)-filtsizeh:centroid(a,1)+filtsizeh); 
    sliced=sliced(:); 
    D(a,1)=corr(dimefilter(:),sliced); 
    D(a,2)=corr(nickelfilter(:),sliced); 
    D(a,3)=corr(quarterfilter (:),sliced); 
end

D

%%%%% 3. Perform k-means clustering of features for unsupervised learning classifier
rng(0);
cls_init=[]; cls=[]; totcount=[];

cls_init=kmeans(D,3,'Replicates',10); 
index1=cls_init==1; 
index2=cls_init==2; 
index3=cls_init==3; 
Average1=mean(component_size(index1)); 
Average2=mean(component_size(index2)); 
Average3=mean(component_size(index3)); 
D=[D cls_init zeros(length(cls_init),1)]; 
for a=1:length(cls_init) 
    if(cls_init(a)==1) 
        D(a,5)=Average1; 
    elseif(cls_init(a)==2) 
        D(a,5)=Average2; 
    else 
        D(a,5)=Average3; 
    end 
end 
min_value=min([Average1 Average2 Average3]); 
max_value=max([Average1 Average2 Average3]); 
D=[D zeros(length(cls_init),1)]; 
for a=1:length(cls_init) 
    if(D(a,5)==min_value) 
        D(a,6)=1; 
    elseif(D(a,5)==max_value) 
        D(a,6)=3; 
    else D(a,6)=2; 
    end 
end 

cls_init
% relabel centroid classes based on average size of the objects in each class. smallest will be dime, next nickel, and largest quarter

cls=D(:,6); 
cls
% Visualize the result
figure; imagesc(im);colormap(gray);title('test image');hold on;axis equal;

% plot circles around each coin with different color/diameter unique to each type and count the change

for a=1:length(cls_init) 
    [coinvalue,x_plot,y_plot,col] = AddCoinToPlotAndCount(centroid(a,1),centroid(a,2),cls(a)); 
    totcount=[totcount coinvalue]; 
end 
totcount=sum(totcount); 
title([num2str(totcount),' cents'])


%%%%%%%%%%%%%%%%%%%% Helper Functions %%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%% Helper Functions %%%%%%%%%%%%%%%%%%%%%

function [filter,xc,yc] = MakeCircleMatchingFilter(diameter,W)
% initialize filter
filter = zeros(W,W);
% define coordinates for the center of the WxW filter
if(rem(W,2) == 0) 
        xc = (W/2+0.5); 
        yc = (W/2+0.5); 
    else 
        xc = (W+1)/2; 
        yc = xc; 
    end 
% Use double-for loops to check if each pixel lies in the foreground of the circle
for a=1:W 
   for b=1:W 
      if(sqrt((a-xc)^2+((b-yc)^2))<=(diameter/2)) 
       filter(a,b)=1; 
      end 
     end 
end 
end


function [msk,thrsh] = OtsuThreshold(im)
hst = imhist(im);
res = otsuthresh(hst);
thrsh = res*255;
msk = im>thrsh;
end

function filter = MakeCircleMatchingFilter(diameter,filtsize)
filter = zeros(filtsize,filtsize);
radius = diameter/2;
c = (filtsize+1)/2;
for i=1:filtsize
    for j=1:filtsize
        if (i-c)*(i-c) + (j-c)*(j-c) <= radius*radius
            filter(i,j) = 1;
        end
    end
end
end

function [msk,thrsh] = OtsuThreshold(im)
hst = imhist(im);
res = otsuthresh(hst);
thrsh = res*255;
msk = im>thrsh;
end

function [coinvalue,x_plot,y_plot,col] = AddCoinToPlotAndCount(x,y,cls)
% initialize radians for defining x_plot and y_plot using cos and sin functions
rads = 0:2*pi/32:2*pi;
% initialize parameters for radius and color of circle for each type of coin
RadiusDIME=22;
RadiusNICKEL=30;
RadiusQUARTER=40; 
% use if-elseif statement to define x_plot, y_plot, col
%   when cls is 1, we found a dime
%   when cls is 2, we found a nickel
%   when cls is 3, we found a quarter
if(cls==1) 
    coinvalue=10; 
    x_plot= x+(RadiusDIME*cos(rads)); 
    y_plot= y+(RadiusDIME*sin(rads)); 
    col='r'; 
elseif(cls==2) 
    coinvalue=5; 
    x_plot= x+(RadiusNICKEL*cos(rads)); 
    y_plot= y+(RadiusNICKEL*sin(rads)); 
    col='g'; 
else 
    coinvalue=25; 
    x_plot= x+(RadiusQUARTER*cos(rads)); 
    y_plot= y+(RadiusQUARTER*sin(rads)); 
    col='m'; 
end


plot(x_plot,y_plot,col);
end
